NameEncoder 30.3积分
在数据挖掘的非常多场景中，往往一个文件夹下包含数万个需要处理的文件。

这些文件的一般用整数序列命名。比如 0.jpg~10000.jpg ，又或者 weather1.csv~weather99999.csv。

然而当数据挖掘工程师进入这些文件夹，输入 ls又或者想写个batch shell 按文件顺序批处理1下。蛋疼的事情发生了:



没错，linux的文件系统是以字典序来排序的。

非常聪明的统计学家往往会受到这些问题的困扰。

作为一个完美主义的数据抽取业务工程师，眼里是容不下沙子的。

怎么办呢?

一种比较容易想到的方式就是在给文件命名的时候增加前缀0.

0.jpg~10000.jpg 变成了 00000.jpg,00001.jpg~10000.jpg,这样就不会有问题了呢。

but~！

在很多场景中，数据是抽样提取的，这意味着数据文件的编码并不是连续的。
可能一个文件夹下只有1000个文件，但是最大编号的csv文件是 987654321.csv
这意味着对于 1.csv需要变成000000001.csv。你会发现，文件名的长度以非常夸张的比率在膨胀。
而这些文件名本身也消耗着巨大的存储。

另外，在很多流式计算的场景中，文件随着时间流逝抽样增量，你无法预测最大编码的文件的文件名长度。
因此补前缀0到x位的编码方式就不是非常的适用了。

ok，你需要实现一种把整数序列转化成字符串序列的编码方式。
使原文件名序列按照整数大小排列得到的序列，和编码后文件名按照字典序得到的序列，两个序列顺序一致。

为了增加文件的可读性，以及减少base64以及进制转换等黑科技。
在编码过程中，仅仅可以使用数字作为编码后的文件名的字符集（不包括后缀）：[0-9]。

举个例子:

我们可以通过增加前缀0补到10位进行编码。
也可以通过去除前缀0进行解码。

def encode(n):
    return "0"*(10-len(str(n))) + str(n)

def decode(s):
    return int(s)
对于1个文件夹下的4个文件如下。

1.jpg
2.jpg
10.jpg
123456789.jpg
在不考虑后缀的情况下，文件名字符串总长度为 1+1+2+9=13.

前缀0的编码后变成

0000000001.jpg
0000000002.jpg
0000000010.jpg
0123456789.jpg
文件名字符串总长度为 10+10+10+10=40.

因此该种编码的膨胀率 为 40/13。

在这里你需要通过Python代码实现2个函数，分别是encode和decode。

def encode(num):
    #todo
    return str


def decode(str):
    #todo
    return num
本题只接受膨胀率小于1.3的方案。
本题有多组数据，每组数据的数据范围均在 0~10^40之间，由python的random生成。
